using System;
using System.Collections.Generic;
using System.Linq;
using SabberStoneCore.Enums;
using SabberStoneCore.Conditions;
using SabberStoneCore.Model;
using SabberStoneCore.Tasks;
using SabberStoneCore.Model.Entities;

namespace SabberStoneCore.Enchants
{
	/// <summary>
	/// Instance which is attached to an <see cref="Entity"/> and applies it's effects
	/// to certain <see cref="IPlayable"/>s. The effects manifest by processing
	/// <see cref="GameTag"/> values within method <see cref="Apply(Entity, GameTag, Int32)"/>
	/// </summary>
	/// <seealso cref="ILazyRemove" />
	public class Enchant : ILazyRemove
	{
		/// <summary>Gets or sets the parent container of this instance.</summary>
		/// <value>The parent container.</value>
		public List<Enchant> Parent { get; set; }

		/// <summary>Gets or sets the conditions which must be met in order to enable the enchant.</summary>
		/// <value>The enable conditions.</value>
		public List<SelfCondition> EnableConditions { get; set; } = new List<SelfCondition>();

		/// <summary>Gets or sets the conditions which must be met in order for this enchant to have an effect
		/// on a certain <see cref="IPlayable"/>.</summary>
		/// <value>The apply conditions.</value>
		public List<RelaCondition> ApplyConditions { get; set; } = new List<RelaCondition>();

		/// <summary>Gets or sets the ID of the card which invoked this enchant.</summary>
		/// <value>The card ID of the enchant source.</value>
		/// <seealso cref="Card.Id"/>
		public string SourceId { get; set; }

		/// <summary>Gets or sets the game for which this enchant is applicable.</summary>
		/// <value><see cref="Model.Game"/></value>
		public Game Game { get; set; }

		private int _ownerId;
		/// <summary>Gets or sets the entity which owns this enchant.</summary>
		/// <value><see cref="IPlayable"/></value>
		public IPlayable Owner
		{
			get { return Game.IdEntityDic[_ownerId]; }
			set { _ownerId = value.Id; }
		}

		/// <summary>Gets or sets the <see cref="GameTag"/>s which are affected by this enchant.
		///	In some cases the set value will used to overwrite the matching tag for applicable
		/// entities during the game;
		/// </summary>
		/// <value>The effects.</value>
		public Dictionary<GameTag, int> Effects { get; set; } = new Dictionary<GameTag, int>();

		/// <summary>Function that produces an integer which simply overwrites the affected
		/// tags.
		/// </summary>
		public Func<IPlayable, int> FixedValueFunc;

		/// <summary>Function that produces an integer which is amended to the original value of the
		/// affected tags.
		/// </summary>
		public Func<IPlayable, int> ValueFunc;

		/// <summary>Gets or sets the amount of turns this enchant is active.</summary>
		/// <value>The number of active turns.</value>
		public int TurnsActive { get; set; } = -1;

		/// <summary>Gets or sets the turn number when this enchant was activated.</summary>
		/// <value>The turn number when activated.</value>
		public int Turn { get; set; }

		/// <summary>Gets or sets the tags which have to change before this enchant will remove itself.</summary>
		/// <value>The tags on which this enchant triggers it's removal.</value>
		public List<GameTag> RemoveTriggerTags { get; set; } = new List<GameTag>();

		/// <summary>Gets or sets the tags and corresponding values for when this enchant removes itself.</summary>
		/// <value>The remove triggers.</value>
		internal Dictionary<GameTag, int> RemoveTriggers { get; set; } = new Dictionary<GameTag, int>();

		/// <summary>Gets or sets the task which is executed when the game cleans up this enchant.</summary>
		/// <value><see cref="ISimpleTask"/></value>
		/// <seealso cref="Remove"/>
		public ISimpleTask SingleTask { get; set; }

		/// <summary>Gets or sets the task which is executed when this enchant marks itself for removal.</summary>
		/// <value><see cref="ISimpleTask"/></value>
		/// <seealso cref="IsEnabled"/>
		public ISimpleTask RemovalTask { get; set; }

		/// <summary>
		/// Initiates removal of the implemented type.
		/// The instance will remove itself from the game.
		/// </summary>
		/// <autogeneratedoc />
		public void Remove()
		{
			if (SingleTask != null)
			{
				if (Game.Logging)
					Game.Log(LogLevel.INFO, BlockType.TRIGGER, "Enchant", "enqueueuing lazy removal task here!");

				// clone task here
				ISimpleTask clone = SingleTask.Clone();
				clone.Game = Owner.Controller.Game;
				clone.Controller = Owner.Controller;
				clone.Source = Owner;
				clone.Target = Owner;

				Owner.Controller.Game.TaskQueue.Enqueue(clone);
			}
			Parent.Remove(this);
		}

		/// <summary>Determines whether this enchant is still active.</summary>
		/// <returns><c>true</c> if this enchant is active; otherwise, <c>false</c>.</returns>
		/// <autogeneratedoc />
		public bool IsEnabled()
		{
			bool flag = true;

			//EnableConditions.ForEach(p => flag &= p.Eval(Owner));

			//RemoveTriggers.ToList().ForEach(p => flag &= Owner.Controller[p.Key] <= p.Value);


			for (int i = 0; i < EnableConditions.Count; i++)
				flag &= EnableConditions[i].Eval(Owner); 
			foreach (KeyValuePair<GameTag, int> kvp in RemoveTriggers)
				flag &= Owner.Controller[kvp.Key] <= kvp.Value;
			


			flag &= TurnsActive < 0 || Owner.Game.Turn <= Turn + TurnsActive;

			if (!flag && !Owner.Game.LazyRemoves.Contains(this))
			{
				Owner.Game.LazyRemoves.Enqueue(this);
				// execute removal task here, ex. health rentantion   
				if (RemovalTask != null)
				{
					if (Game.Logging)
						Game.Log(LogLevel.INFO, BlockType.TRIGGER, "Enchant", "executing removal task priority here");
					Owner.Controller.Game.TaskQueue.Execute(RemovalTask, Owner.Controller, Owner, Owner);
				}
			}

			return flag;
		}

		private bool IsApplying(IPlayable target)
		{
			bool flag = true;
			//ApplyConditions.ForEach(p => flag &= p.Eval(Owner, target));
			for (int i = 0; i < ApplyConditions.Count; i++)
				flag &= ApplyConditions[i].Eval(Owner, target);
			return flag;
		}

		/// <summary>Applies this enchant on the specified entity and tag.
		///	This method will process the stored data and apply it to the provided
		///	tag value, when applicable.
		/// </summary>
		/// <param name="entity">The entity subject.</param>
		/// <param name="gameTag">The game tag which must change.</param>
		/// <param name="value">The value of the corresponding tag. This value is either original (native) or
		/// could already be the result of another enchant.</param>
		/// <returns>An updated value for the specified tag.</returns>
		public int Apply(Entity entity, GameTag gameTag, int value)
		{

			// only allow enchantments on playable entitys ...
			var target = entity as IPlayable;
			//if (target == null && !(entity is Controller))
			//{
			//    return value;
			//}

			if (!Effects.ContainsKey(gameTag))
			{
				if (Game.Logging)
					Game.Log(LogLevel.DEBUG, BlockType.TRIGGER, "Enchant", $"GameTag {gameTag} not concerned by this enchanting ...");
				return value;
			}

			if (!IsEnabled())
			{
				if (Game.Logging)
					Game.Log(LogLevel.DEBUG, BlockType.TRIGGER, "Enchant", $"Enchant from {Owner} isn't enabled! {target}");
				return value;
			}

			if (!IsApplying(target))
			{
				if (Game.Logging)
					Game.Log(LogLevel.DEBUG, BlockType.TRIGGER, "Enchant", $"Enchant conditions not meet.");
				return value;
			}

			if (FixedValueFunc != null)
			{
				if (Game.Logging)
					Game.Log(LogLevel.DEBUG, BlockType.TRIGGER, "Enchant", $"Card[ind.{target.OrderOfPlay}.{target}] got enchanted. Using fixed value func.");
				return FixedValueFunc.Invoke(Owner);
			}

			if (Game.Logging)
				Game.Log(LogLevel.DEBUG, BlockType.TRIGGER, "Enchant", $"Card[ind.{target?.OrderOfPlay}.{target}] got enchanted. {gameTag} = {value} + {Effects[gameTag]} variable effect? {ValueFunc != null}");

			// apply variable effects if we have ...
			int effect = ValueFunc?.Invoke(Owner) ?? Effects[gameTag];

			// TODO find an elegant way for that ... check if gametag is bool
			if (gameTag == GameTag.CHARGE || gameTag == GameTag.WINDFURY || gameTag == GameTag.IMMUNE)
			{
				return (value + effect) == 0 ? 0 : 1;
			}

			// TODO this is really bad practice
			if (gameTag == GameTag.BATTLECRY)
			{
				return value != 0 ? (value + effect) : 0;
			}

			int result = value + effect;

			// TODO don't allow negative values for those tags ... for all???
			if (result < 0) // && (gameTag == GameTag.COST || gameTag == GameTag.ATK))
			{
				result = 0;
			}

			// enchanting value
			return result;

		}

		/// <summary>Activates this enchant on the specified entity.</summary>
		/// <param name="sourceId">The source identifier.</param>
		/// <param name="parent">The parent container.</param>
		/// <param name="owner">The owner/carrier of this enchant.</param>
		public void Activate(string sourceId, List<Enchant> parent, IPlayable owner)
		{
			parent.Add(Copy(sourceId, owner.Game, owner.Game.Turn, parent, owner, RemoveTriggerTags.ToDictionary(p => p, p => owner.Controller[p])));
		}

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

		public string Hash => $"{SourceId}{(TurnsActive > -1 ? $",{Turn}" : "")}";

		public Enchant Copy(string sourceId, Game game, int turn, List<Enchant> parent, IPlayable owner, Dictionary<GameTag, int> removeTriggers)
		{
			return new Enchant()
			{
				Game = game,
				Parent = parent,
				Owner = owner,
				Turn = turn,

				SourceId = sourceId,
				EnableConditions = EnableConditions,
				ApplyConditions = ApplyConditions,
				SingleTask = SingleTask?.Clone(),
				RemovalTask = RemovalTask?.Clone(),
				Effects = new Dictionary<GameTag, int>(Effects),
				ValueFunc = ValueFunc,
				FixedValueFunc = FixedValueFunc,
				TurnsActive = TurnsActive,

				RemoveTriggerTags = new List<GameTag>(RemoveTriggerTags),
				RemoveTriggers = new Dictionary<GameTag, int>(removeTriggers),
			};
		}
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
	}

}
