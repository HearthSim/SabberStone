using System.Collections.Generic;
using System.Text;
using SabberStoneCore.Enums;
using SabberStoneCore.Kettle;

namespace SabberStoneCore.Model.Entities
{
	/// <summary>
	/// The entity representing the player.
	/// </summary>
	/// <seealso cref="Character{Hero}" />
	/// <autogeneratedoc />
	public partial class Hero : Character<Hero>
	{
		/// <summary>Gets or sets the hero power entity.</summary>
		/// <value><see cref="HeroPower"/></value>
		public HeroPower Power { get; set; }

		/// <summary>Gets or sets the weapon entity equipped on the Hero.</summary>
		/// <value><see cref="Entities.Weapon"/></value>
		public Weapon Weapon { get; set; }

		/// <summary>Initializes a new instance of the <see cref="Hero"/> class.</summary>
		/// <param name="controller">Owner of the character; not specifically limited to players.</param>
		/// <param name="card">The card which this character embodies.</param>
		/// <param name="tags">Properties of this entity.</param>
		/// <autogeneratedoc />
		public Hero(Controller controller, Card card, Dictionary<GameTag, int> tags)
			: base(controller, card, tags)
		{
			Game.Log(LogLevel.VERBOSE, BlockType.PLAY, "Hero", $"{card.Name} ({card.Class}) was created.");
		}

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

		public override int AttackDamage => base.AttackDamage + (Game.CurrentPlayer != Controller ? 0 : Weapon?.AttackDamage ?? 0);

		public int TotalAttackDamage => AttackDamage/* + (Weapon?.AttackDamage ?? 0)*/;

		public override bool CanAttack => TotalAttackDamage > 0 && base.CanAttack;

		public override bool HasWindfury => base.HasWindfury || Weapon != null && Weapon.HasWindfury;

		public void AddWeapon(Weapon weapon)
		{
			RemoveWeapon();
			weapon.SetOrderOfPlay("WEAPON");
			Weapon = weapon;
			Weapon[GameTag.ZONE] = (int)Enums.Zone.PLAY;
			Weapon[GameTag.ZONE_POSITION] = 0;
			if (Game.History)
			{
				Game.PowerHistory.Add(PowerHistoryBuilder.BlockStart(BlockType.POWER, Weapon.Id, "", -1, 0));
				Game.PowerHistory.Add(PowerHistoryBuilder.BlockEnd());
			}
			EquippedWeapon = weapon.Id;
		}

		public void RemoveWeapon()
		{
			if (Weapon == null)
			{
				return;
			}

			if (Weapon.HasDeathrattle)
			{
				Weapon.ApplyEnchantments(EnchantmentActivation.DEATHRATTLE, Enums.Zone.GRAVEYARD);
			}
			if (Game.Logging)
				Game.Log(LogLevel.INFO, BlockType.PLAY, "Hero", $"Butcher's knife incoming to graveyard, say 'gugus' to {Weapon}");
			Controller.GraveyardZone.Add(Weapon);
			Weapon = null;
			EquippedWeapon = 0;
		}

		public string FullPrint()
		{
			var str = new StringBuilder();
			string mStr = Weapon != null ? $"[{Weapon.Card.Name}[{Weapon.AttackDamage}/{Weapon.Durability}]]" : "[NO WEAPON]";
			str.Append($"[HERO][{this}][ATK{AttackDamage}/AR{Armor}/HP{Health}][{mStr}][SP{SpellPowerDamage}]");
			str.Append($"[ENCH {Enchants.Count}]");
			str.Append($"[TRIG {Triggers.Count}]");
			return str.ToString();
		}

#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
	}

	public partial class Hero
	{
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

		public int SpellPowerDamage
		{
			get { return this[GameTag.SPELLPOWER]; }
			set { this[GameTag.SPELLPOWER] = value; }
		}

		public int EquippedWeapon
		{
			get { return this[GameTag.WEAPON]; }
			set { this[GameTag.WEAPON] = value; }
		}

		public int HeroPowerDamage
		{
			get { return this[GameTag.HEROPOWER_DAMAGE]; }
			set { this[GameTag.HEROPOWER_DAMAGE] = value; }
		}

		public int Fatigue
		{
			get { return this[GameTag.FATIGUE]; }
			set { this[GameTag.FATIGUE] = value; }
		}

#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
	}
}
